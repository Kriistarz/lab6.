# Рязанова Кристина ИТ-8 Лабораторная №6

# Задание 1
## Задача 1
### Текст задачи
@Invoke.
Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные
аннотацией @Invoke, и вызывает их автоматически.
### Алгоритм решения
1. Создать аннотацию @Invoke
Указать, что цель аннотации — метод.
Установить время жизни — runtime.
Не добавлять никаких свойств.
2. Создать класс с методами
Добавить несколько обычных методов.
Один или несколько методов пометить аннотацией @Invoke.
3. Создать обработчик аннотации
Принять объект для анализа.
Получить все методы его класса через Reflection.
Перебрать методы:
если метод помечен @Invoke → вызвать его через invoke().
Обработать возможные ошибки вызова.

## Задача 2
### Текст задачи
@Default.
Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.
### Алгоритм решения
1. Создать аннотацию @Default
Указать цели: тип и поле.
Установить время жизни — runtime.
Создать обязательное свойство value типа Class.
2. Создать класс и пометить его @Default
Передать в аннотацию какой-либо класс в качестве значения по умолчанию.
3. Создать обработчик
Проверить, имеет ли класс аннотацию @Default.
Если да → получить значение value() и вывести имя класса.
Если нет → вывести сообщение об отсутствии аннотации.

## Задача 3
### Текст задачи
@ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,
где @ToString имеет значение YES.
### Алгоритм решения
1. Создать аннотацию @ToString
Указать цели: тип и поле.
Установить время жизни — runtime.
Создать перечисление Mode с вариантами YES и NO.
Создать свойство value с режимом Mode.YES по умолчанию.
2. Создать класс
Пометить весь класс @ToString.
Несколько полей оставить без аннотации (они считаются YES).
Одно поле пометить @ToString(Mode.NO).
3. Создать обработчик (метод buildString)
Если на классе нет @ToString — вернуть обычный toString().
Иначе:
Получить все поля.
Для каждого поля:
если нет аннотации или аннотация = YES → включить поле в строку;
если Mode.NO → пропустить.
Сформировать строку вида:
ClassName{field=value; ...}

## Задача 4
### Текст задачи
@Validate.
Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.
### Алгоритм решения
1. Создать аннотацию @Validate
Цели: тип и аннотация.
Установить время жизни — runtime.
Создать обязательное свойство value типа Class[].
2. Проаннотировать класс @Validate
Передать в аннотацию массив классов.
3. Создать обработчик
Проверить наличие аннотации у класса.
Если аннотация есть → получить массив классов и вывести их имена.
Если нет → вывести сообщение об отсутствии аннотации. 

## Задача 5
### Текст задачи
@Two.
Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.
### Алгоритм решения
1. Создать аннотацию @Two
Указать цель: тип.
Установить время жизни — runtime.
Создать два обязательных свойства:
first — String
second — int
2. Проаннотировать класс @Two
Указать строку и число.
3. Создать обработчик
Проверить, есть ли у класса @Two.
Если есть → получить свойства first и second и вывести их.
Если нет → вывести сообщение.

## Задача 6
### Текст задачи
@Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что
список пуст.
### Алгоритм решения
1. Создать аннотацию @Cache
Цель: тип.
Время жизни: runtime.
Создать свойство value типа String[] с дефолтным значением пустого массива.
2. Проаннотировать класс
Передать несколько строковых значений — названия кешируемых областей.
3. Создать обработчик
Проверить наличие аннотации у класса.
Получить массив областей.
Если массив пуст → вывести сообщение «список пуст».
Иначе → вывести каждую область.

# Задание 2
## Задача 1
### Текст задачи
Напишите тест, используя фреймворк JUnit, к методу toString() (или методу, формирующему
строковое представление объекта, основанное на аннотации @ToString).
• Проверить, что в результирующей строке отображаются только те поля, которые имеют
аннотацию @ToString(Mode.YES) или не аннотированы вовсе.
• Убедиться, что поля с @ToString(Mode.NO) не попадают в вывод.
### Алгоритм решения
1. Создать тестовый объект класса, помеченного @ToString
Инициализировать объект.
2. Вызвать метод buildString
Сохранить полученную строку.
3. Проверить корректность результата
Убедиться, что в строке присутствуют поля с Mode.YES и поля без аннотации.
Убедиться, что поле с Mode.NO отсутствует.
Использовать assertTrue() и assertFalse().

## Задача 5
### Текст задачи
Реализовать тест, используя фреймворк JUnit, для класса, использующего аннотацию @Cache.
• Проверить, что список кешируемых сущностей (value) корректно считывается.
• Реализовать мок-тест (с использованием Mockito или встроенных подстановок),
имитирующий обращение к кешу.
• Проверить, что если массив пуст – кеширование не производится.
• Добавить отдельный тест для случая, когда кеш содержит несколько именованных
областей.
### Алгоритм решения
1. Подготовка (Setup/Teardown)
Захват вывода: Создаем временный буфер (ByteArrayOutputStream), чтобы перехватывать текст, который CacheProcessor печатает в консоль.
Изоляция: С помощью @BeforeEach перенаправляем System.out в буфер, а после теста (@AfterEach) возвращаем настройки обратно, чтобы тесты не мешали друг другу.
2. Тест считывания (Reflection)
Проверка данных: Берем реальный класс CacheExample и проверяем, что JUnit видит аннотацию @Cache и корректно считывает её массив value (users, products, logs).
3. Тест-заглушка (Manual Stub)
Имитация: Вручную создаем объект интерфейса Cache (анонимный класс). Это позволяет проверить работу «в чистом виде», не привязываясь к файлам проекта.
4. Тест логики (Functional)
Пустой список: Создаем временный класс с @Cache({}) и проверяем, что процессор выдал сообщение «Список кешируемых областей пуст».
Несколько областей: Запускаем процессор для CacheExample и проверяем наличие всех трех строк в итоговом выводе.[lab6.md](https://github.com/user-attachments/files/24697853/lab6.md)
.
